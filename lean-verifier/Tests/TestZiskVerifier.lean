/-
  End-to-end tests for Zisk STARK proof verification (VADCOP mode).

  Translates: executable-spec/tests/test_zisk_verifier_e2e.py

  Tests that the Lean verifier correctly verifies proofs generated by
  the C++ GPU prover for Zisk zkVM AIRs. Each test loads a binary proof,
  the corresponding starkinfo and verkey from the Zisk proving key,
  derives the VADCOP global_challenge from per-AIR data, and verifies
  the proof passes starkVerify.

  Requires:
    - Binary proof fixtures in tests/test-data/zisk/proofs/*.proof.bin
    - publics.json and proof_values.json in tests/test-data/zisk/
    - Zisk proving key at ZISK_PROVING_KEY env var or ../zisk-for-spec/provingKey
-/
import LSpec
import Protocol.Verifier
import Protocol.ChallengeUtils
import Protocol.StarkInfo
import Protocol.Proof
import Primitives.Field
import Lean.Data.Json
import Lean.Data.Json.Parser
import Std

open LSpec
open Protocol.Verifier
open Protocol.ChallengeUtils
open Protocol.StarkInfo (StarkInfo)
open Protocol.Proof (STARKProof decodeAllUInt64)
open Primitives.Field

-- ============================================================================
-- Configuration
-- ============================================================================

/-- AIR name and proof filename stem pairs.
    Generated from Fibonacci(10) guest on zisk-for-spec v0.15.0 GPU prover. -/
def ZISK_AIRS : Array (String × String) := #[
  ("Main", "Main_0"),
  ("Rom", "Rom_1"),
  ("Mem", "Mem_2"),
  ("RomData", "RomData_3"),
  ("InputData", "InputData_4"),
  ("MemAlign", "MemAlign_5"),
  ("BinaryExtension", "BinaryExtension_6"),
  ("BinaryAdd", "BinaryAdd_7"),
  ("Binary", "Binary_8"),
  ("SpecifiedRanges", "SpecifiedRanges_9"),
  ("VirtualTable0", "VirtualTable0_10"),
  ("VirtualTable1", "VirtualTable1_11")
]

def TEST_DATA_DIR : String := "Tests/test-data/zisk"

-- ============================================================================
-- Path helpers
-- ============================================================================

/-- Get Zisk proving key directory from env or default. -/
def getProvingKeyDir : IO String := do
  let envVar ← IO.getEnv "ZISK_PROVING_KEY"
  match envVar with
  | some dir => return dir
  | none => return "../zisk-for-spec/provingKey"

def starkInfoPath (pkDir airName : String) : String :=
  s!"{pkDir}/zisk/Zisk/airs/{airName}/air/{airName}.starkinfo.json"

def verkeyJsonPath (pkDir airName : String) : String :=
  s!"{pkDir}/zisk/Zisk/airs/{airName}/air/{airName}.verkey.json"

def bytecodeBinPath (pkDir airName : String) : String :=
  s!"{pkDir}/zisk/Zisk/airs/{airName}/air/{airName}.bin"

def proofBinPath (proofStem : String) : String :=
  s!"{TEST_DATA_DIR}/proofs/{proofStem}.proof.bin"

-- ============================================================================
-- JSON parsing helpers
-- ============================================================================

/-- Parse a JSON array of integer strings into UInt64 array. -/
def parseJsonUInt64Array (json : Lean.Json) : Except String (Array UInt64) := do
  let arr ← json.getArr?
  let mut result : Array UInt64 := #[]
  for item in arr do
    match item with
    | .str s =>
      match s.toNat? with
      | some n => result := result.push n.toUInt64
      | none => throw s!"Invalid number string: {s}"
    | .num n => result := result.push n.mantissa.toNat.toUInt64
    | _ => throw s!"Expected string or number in array"
  return result

/-- Parse verkey JSON: array of uint64 values. -/
def loadVerkeyJson (path : String) : IO (Array UInt64) := do
  let contents ← IO.FS.readFile path
  match Lean.Json.parse contents with
  | .ok json =>
    let arr ← IO.ofExcept (json.getArr?)
    let mut result : Array UInt64 := #[]
    for item in arr do
      match item with
      | .num n => result := result.push (n.mantissa.toNat.toUInt64)
      | _ => throw (IO.userError s!"Expected number in verkey array")
    return result
  | .error e => throw (IO.userError s!"JSON parse error: {e}")

/-- Load publics from JSON file (array of string-encoded integers). -/
def loadPublics : IO (Array UInt64) := do
  let contents ← IO.FS.readFile s!"{TEST_DATA_DIR}/publics.json"
  match Lean.Json.parse contents with
  | .ok json => IO.ofExcept (parseJsonUInt64Array json)
  | .error e => throw (IO.userError s!"JSON parse error: {e}")

/-- Load proof_values from JSON file (array of [c0, c1, c2] triples). -/
def loadProofValues : IO (Array (Array UInt64)) := do
  let contents ← IO.FS.readFile s!"{TEST_DATA_DIR}/proof_values.json"
  match Lean.Json.parse contents with
  | .ok json =>
    let arr ← IO.ofExcept (json.getArr?)
    let mut result : Array (Array UInt64) := #[]
    for item in arr do
      let triple ← IO.ofExcept (parseJsonUInt64Array item)
      result := result.push triple
    return result
  | .error e => throw (IO.userError s!"JSON parse error: {e}")

-- ============================================================================
-- GlobalInfo parsing
-- ============================================================================

structure GlobalInfo where
  latticeSize : Nat
  transcriptArity : Nat
  nPublics : Nat
  proofValuesMap : Array (String × Nat)  -- (name, stage) pairs
  deriving Repr

def loadGlobalInfo (pkDir : String) : IO GlobalInfo := do
  let path := s!"{pkDir}/pilout.globalInfo.json"
  let contents ← IO.FS.readFile path
  match Lean.Json.parse contents with
  | .ok json =>
    let latticeSize ← IO.ofExcept (json.getObjValAs? Nat "latticeSize")
    let transcriptArity ← IO.ofExcept (json.getObjValAs? Nat "transcriptArity")
    let nPublics ← IO.ofExcept (json.getObjValAs? Nat "nPublics")
    let pvmArr ← IO.ofExcept ((json.getObjVal? "proofValuesMap").bind Lean.Json.getArr?)
    let mut pvMap : Array (String × Nat) := #[]
    for item in pvmArr do
      let name ← IO.ofExcept (item.getObjValAs? String "name")
      let stage ← IO.ofExcept (item.getObjValAs? Nat "stage")
      pvMap := pvMap.push (name, stage)
    return { latticeSize, transcriptArity, nPublics, proofValuesMap := pvMap }
  | .error e => throw (IO.userError s!"JSON parse error in globalInfo: {e}")

-- ============================================================================
-- VADCOP global challenge derivation
-- ============================================================================

/-- Derive the VADCOP global challenge from per-AIR proof data.
    Translates: test_zisk_verifier_e2e.py:88-159 _derive_global_challenge -/
def deriveZiskGlobalChallenge (pkDir : String) : IO (Array UInt64) := do
  let globalInfo ← loadGlobalInfo pkDir

  -- Compute per-AIR contributions
  let mut contributions : Array (Array UInt64) := #[]
  for (airName, proofStem) in ZISK_AIRS do
    let siPath := starkInfoPath pkDir airName
    let siJson ← IO.FS.readFile siPath
    let starkInfo ← match Lean.Json.parse siJson >>= StarkInfo.fromJson? with
      | .ok si => pure si
      | .error e => throw (IO.userError s!"Failed to parse starkinfo for {airName}: {e}")

    -- Load verkey
    let verkey ← loadVerkeyJson (verkeyJsonPath pkDir airName)

    -- Parse binary proof to get root1 and air_values
    let proofData ← IO.FS.readBinFile (proofBinPath proofStem)
    let proof := STARKProof.fromBytes proofData starkInfo

    -- Extract root1 (Stage 1 Merkle root)
    let root1 := proof.roots[0]!

    -- Extract stage 1 air_values (first component of each FF3 triple)
    let mut stage1AirValues : Array UInt64 := #[]
    for avIdx in [:starkInfo.airValuesMap.size] do
      let avMap := starkInfo.airValuesMap[avIdx]!
      if avMap.stage == 1 then
        if avIdx < proof.airValues.size then
          stage1AirValues := stage1AirValues.push proof.airValues[avIdx]![0]!

    -- Compute contribution
    let airValues := if stage1AirValues.size > 0 then stage1AirValues else #[]
    let contribution := calculateInternalContribution
      starkInfo.starkStruct.transcriptArity
      verkey root1 airValues globalInfo.latticeSize
    contributions := contributions.push contribution

  -- Load publics and proof_values
  let publics ← loadPublics
  let proofValuesRaw ← loadProofValues

  -- Extract stage 1 proof values (first component of each FF3)
  let mut proofValuesStage1 : Array UInt64 := #[]
  for i in [:proofValuesRaw.size] do
    if i < globalInfo.proofValuesMap.size then
      let (_, stage) := globalInfo.proofValuesMap[i]!
      if stage == 1 then
        proofValuesStage1 := proofValuesStage1.push proofValuesRaw[i]![0]!

  let globalChallenge := deriveGlobalChallengeMultiAir
    publics globalInfo.nPublics proofValuesStage1 contributions
    globalInfo.transcriptArity globalInfo.latticeSize

  return globalChallenge

-- ============================================================================
-- E2E Verification
-- ============================================================================

/-- Verify a single Zisk AIR proof. -/
def verifyZiskAir (pkDir : String) (airName proofStem : String)
    (globalChallenge publics : Array UInt64) : IO Bool := do
  let siPath := starkInfoPath pkDir airName
  let siJson ← IO.FS.readFile siPath
  let starkInfo ← match Lean.Json.parse siJson >>= StarkInfo.fromJson? with
    | .ok si => pure si
    | .error e => throw (IO.userError s!"Failed to parse starkinfo for {airName}: {e}")

  let proofData ← IO.FS.readBinFile (proofBinPath proofStem)
  let proof := STARKProof.fromBytes proofData starkInfo

  let verkey ← loadVerkeyJson (verkeyJsonPath pkDir airName)
  let bcPath := bytecodeBinPath pkDir airName

  let result := starkVerify proof starkInfo verkey siPath bcPath
    (globalChallenge := some globalChallenge)
    (publics := some publics)

  return result

-- ============================================================================
-- Test runner
-- ============================================================================

def main : IO UInt32 := do
  -- Check if Zisk proving key exists
  let pkDir ← getProvingKeyDir
  let globalInfoExists ← System.FilePath.pathExists s!"{pkDir}/pilout.globalInfo.json"

  if !globalInfoExists then
    IO.eprintln s!"Skipping Zisk E2E tests: proving key not found at {pkDir}"
    IO.eprintln "Set ZISK_PROVING_KEY env var to the proving key directory"
    return 0

  -- Check if proof fixtures exist
  let firstProof := proofBinPath "Main_0"
  let proofsExist ← System.FilePath.pathExists firstProof
  if !proofsExist then
    IO.eprintln s!"Skipping Zisk E2E tests: proof fixtures not found at {firstProof}"
    return 0

  -- Derive global challenge (shared across all AIRs)
  IO.println "Deriving VADCOP global challenge..."
  let globalChallenge ← deriveZiskGlobalChallenge pkDir
  IO.println s!"  global_challenge = [{globalChallenge[0]!}, {globalChallenge[1]!}, {globalChallenge[2]!}]"

  let publics ← loadPublics

  -- Verify each AIR
  let mut allTests : TestSeq := .done
  let mut passCount : Nat := 0
  let mut failCount : Nat := 0

  for (airName, proofStem) in ZISK_AIRS do
    IO.println s!"Verifying {airName}..."
    let result ← verifyZiskAir pkDir airName proofStem globalChallenge publics
    if result then
      passCount := passCount + 1
    else
      failCount := failCount + 1
    allTests := allTests ++ test s!"{airName} proof verifies" result

  IO.println s!"\nResults: {passCount} passed, {failCount} failed out of {ZISK_AIRS.size}"

  lspecIO (.ofList [("Zisk Verifier E2E", [allTests])]) []
