/-
  End-to-end tests for Zisk STARK proof verification (VADCOP mode).

  Translates: executable-spec/tests/test_zisk_verifier_e2e.py

  Tests that the Lean verifier correctly verifies proofs generated by
  the C++ GPU prover for Zisk zkVM AIRs. Each test loads a binary proof,
  the corresponding starkinfo and verkey from bundled test fixtures,
  derives the VADCOP global_challenge from per-AIR data, and verifies
  the proof passes starkVerify.

  All test fixtures are self-contained in Tests/test-data/zisk/.
-/
import LSpec
import Protocol.Verifier
import Protocol.ChallengeUtils
import Protocol.StarkInfo
import Protocol.Proof
import Primitives.Field
import Lean.Data.Json
import Lean.Data.Json.Parser
import Std

open LSpec
open Protocol.Verifier
open Protocol.ChallengeUtils
open Protocol.StarkInfo (StarkInfo)
open Protocol.Proof (STARKProof decodeAllUInt64)
open Primitives.Field

-- ============================================================================
-- Configuration
-- ============================================================================

/-- AIR name and proof filename stem pairs.
    Generated from Fibonacci(10) guest on zisk-for-spec v0.15.0 GPU prover. -/
def ZISK_AIRS : Array (String × String) := #[
  ("Main", "Main_0"),
  ("Rom", "Rom_1"),
  ("Mem", "Mem_2"),
  ("RomData", "RomData_3"),
  ("InputData", "InputData_4"),
  ("MemAlign", "MemAlign_5"),
  ("BinaryExtension", "BinaryExtension_6"),
  ("BinaryAdd", "BinaryAdd_7"),
  ("Binary", "Binary_8"),
  ("SpecifiedRanges", "SpecifiedRanges_9"),
  ("VirtualTable0", "VirtualTable0_10"),
  ("VirtualTable1", "VirtualTable1_11")
]

def TEST_DATA_DIR : String := "Tests/test-data/zisk"

-- ============================================================================
-- Path helpers
-- ============================================================================

def starkInfoPath (airName : String) : String :=
  s!"{TEST_DATA_DIR}/airs/{airName}/{airName}.starkinfo.json"

def verkeyJsonPath (airName : String) : String :=
  s!"{TEST_DATA_DIR}/airs/{airName}/{airName}.verkey.json"

def bytecodeBinPath (airName : String) : String :=
  s!"{TEST_DATA_DIR}/airs/{airName}/{airName}.bin"

def proofBinPath (proofStem : String) : String :=
  s!"{TEST_DATA_DIR}/proofs/{proofStem}.proof.bin"

-- ============================================================================
-- JSON parsing helpers
-- ============================================================================

/-- Parse a JSON array of integer strings into UInt64 array. -/
def parseJsonUInt64Array (json : Lean.Json) : Except String (Array UInt64) := do
  let arr ← json.getArr?
  let mut result : Array UInt64 := #[]
  for item in arr do
    match item with
    | .str s =>
      match s.toNat? with
      | some n => result := result.push n.toUInt64
      | none => throw s!"Invalid number string: {s}"
    | .num n => result := result.push n.mantissa.toNat.toUInt64
    | _ => throw s!"Expected string or number in array"
  return result

/-- Parse verkey JSON: array of uint64 values. -/
def loadVerkeyJson (path : String) : IO (Array UInt64) := do
  let contents ← IO.FS.readFile path
  match Lean.Json.parse contents with
  | .ok json =>
    let arr ← IO.ofExcept (json.getArr?)
    let mut result : Array UInt64 := #[]
    for item in arr do
      match item with
      | .num n => result := result.push (n.mantissa.toNat.toUInt64)
      | _ => throw (IO.userError s!"Expected number in verkey array")
    return result
  | .error e => throw (IO.userError s!"JSON parse error: {e}")

/-- Load publics from JSON file (array of string-encoded integers). -/
def loadPublics : IO (Array UInt64) := do
  let contents ← IO.FS.readFile s!"{TEST_DATA_DIR}/publics.json"
  match Lean.Json.parse contents with
  | .ok json => IO.ofExcept (parseJsonUInt64Array json)
  | .error e => throw (IO.userError s!"JSON parse error: {e}")

/-- Load proof_values from JSON file (array of [c0, c1, c2] triples). -/
def loadProofValues : IO (Array (Array UInt64)) := do
  let contents ← IO.FS.readFile s!"{TEST_DATA_DIR}/proof_values.json"
  match Lean.Json.parse contents with
  | .ok json =>
    let arr ← IO.ofExcept (json.getArr?)
    let mut result : Array (Array UInt64) := #[]
    for item in arr do
      let triple ← IO.ofExcept (parseJsonUInt64Array item)
      result := result.push triple
    return result
  | .error e => throw (IO.userError s!"JSON parse error: {e}")

-- ============================================================================
-- GlobalInfo parsing
-- ============================================================================

structure GlobalInfo where
  latticeSize : Nat
  transcriptArity : Nat
  nPublics : Nat
  proofValuesMap : Array (String × Nat)  -- (name, stage) pairs
  deriving Repr

def loadGlobalInfo : IO GlobalInfo := do
  let path := s!"{TEST_DATA_DIR}/pilout.globalInfo.json"
  let contents ← IO.FS.readFile path
  match Lean.Json.parse contents with
  | .ok json =>
    let latticeSize ← IO.ofExcept (json.getObjValAs? Nat "latticeSize")
    let transcriptArity ← IO.ofExcept (json.getObjValAs? Nat "transcriptArity")
    let nPublics ← IO.ofExcept (json.getObjValAs? Nat "nPublics")
    let pvmArr ← IO.ofExcept ((json.getObjVal? "proofValuesMap").bind Lean.Json.getArr?)
    let mut pvMap : Array (String × Nat) := #[]
    for item in pvmArr do
      let name ← IO.ofExcept (item.getObjValAs? String "name")
      let stage ← IO.ofExcept (item.getObjValAs? Nat "stage")
      pvMap := pvMap.push (name, stage)
    return { latticeSize, transcriptArity, nPublics, proofValuesMap := pvMap }
  | .error e => throw (IO.userError s!"JSON parse error in globalInfo: {e}")

-- ============================================================================
-- VADCOP global challenge derivation
-- ============================================================================

/-- Derive the VADCOP global challenge from per-AIR proof data.
    Translates: test_zisk_verifier_e2e.py:88-159 _derive_global_challenge -/
def deriveZiskGlobalChallenge : IO (Array UInt64) := do
  let globalInfo ← loadGlobalInfo

  -- Compute per-AIR contributions
  let mut contributions : Array (Array UInt64) := #[]
  for (airName, proofStem) in ZISK_AIRS do
    let siPath := starkInfoPath airName
    let siJson ← IO.FS.readFile siPath
    let starkInfo ← match Lean.Json.parse siJson >>= StarkInfo.fromJson? with
      | .ok si => pure si
      | .error e => throw (IO.userError s!"Failed to parse starkinfo for {airName}: {e}")

    -- Load verkey
    let verkey ← loadVerkeyJson (verkeyJsonPath airName)

    -- Parse binary proof to get root1 and air_values
    let proofData ← IO.FS.readBinFile (proofBinPath proofStem)
    let proof := STARKProof.fromBytes proofData starkInfo

    -- Extract root1 (Stage 1 Merkle root)
    let root1 := proof.roots[0]!

    -- Extract stage 1 air_values (first component of each FF3 triple)
    let mut stage1AirValues : Array UInt64 := #[]
    for avIdx in [:starkInfo.airValuesMap.size] do
      let avMap := starkInfo.airValuesMap[avIdx]!
      if avMap.stage == 1 then
        if avIdx < proof.airValues.size then
          stage1AirValues := stage1AirValues.push proof.airValues[avIdx]![0]!

    -- Compute contribution
    let airValues := if stage1AirValues.size > 0 then stage1AirValues else #[]
    let contribution := calculateInternalContribution
      starkInfo.starkStruct.transcriptArity
      verkey root1 airValues globalInfo.latticeSize
    contributions := contributions.push contribution

  -- Load publics and proof_values
  let publics ← loadPublics
  let proofValuesRaw ← loadProofValues

  -- Extract stage 1 proof values (first component of each FF3)
  let mut proofValuesStage1 : Array UInt64 := #[]
  for i in [:proofValuesRaw.size] do
    if i < globalInfo.proofValuesMap.size then
      let (_, stage) := globalInfo.proofValuesMap[i]!
      if stage == 1 then
        proofValuesStage1 := proofValuesStage1.push proofValuesRaw[i]![0]!

  let globalChallenge := deriveGlobalChallengeMultiAir
    publics globalInfo.nPublics proofValuesStage1 contributions
    globalInfo.transcriptArity globalInfo.latticeSize

  return globalChallenge

-- ============================================================================
-- E2E Verification
-- ============================================================================

/-- Verify a single Zisk AIR proof. -/
def verifyZiskAir (airName proofStem : String)
    (globalChallenge publics : Array UInt64) : IO Bool := do
  let siPath := starkInfoPath airName
  let siJson ← IO.FS.readFile siPath
  let starkInfo ← match Lean.Json.parse siJson >>= StarkInfo.fromJson? with
    | .ok si => pure si
    | .error e => throw (IO.userError s!"Failed to parse starkinfo for {airName}: {e}")

  let proofData ← IO.FS.readBinFile (proofBinPath proofStem)
  let proof := STARKProof.fromBytes proofData starkInfo

  let verkey ← loadVerkeyJson (verkeyJsonPath airName)
  let bcPath := bytecodeBinPath airName

  let result := starkVerify proof starkInfo verkey siPath bcPath
    (globalChallenge := some globalChallenge)
    (publics := some publics)

  return result

-- ============================================================================
-- Test runner
-- ============================================================================

def main : IO UInt32 := do
  -- Check if test fixtures exist
  let globalInfoPath := s!"{TEST_DATA_DIR}/pilout.globalInfo.json"
  let globalInfoExists ← System.FilePath.pathExists globalInfoPath
  if !globalInfoExists then
    IO.eprintln s!"Zisk E2E tests: fixtures not found at {globalInfoPath}"
    return 1

  let firstProof := proofBinPath "Main_0"
  let proofsExist ← System.FilePath.pathExists firstProof
  if !proofsExist then
    IO.eprintln s!"Zisk E2E tests: proof fixtures not found at {firstProof}"
    return 1

  -- Derive global challenge (shared across all AIRs)
  IO.println "Deriving VADCOP global challenge..."
  let globalChallenge ← deriveZiskGlobalChallenge
  IO.println s!"  global_challenge = [{globalChallenge[0]!}, {globalChallenge[1]!}, {globalChallenge[2]!}]"

  let publics ← loadPublics

  -- Verify each AIR
  let mut allTests : TestSeq := .done
  let mut passCount : Nat := 0
  let mut failCount : Nat := 0

  for (airName, proofStem) in ZISK_AIRS do
    IO.println s!"Verifying {airName}..."
    let result ← verifyZiskAir airName proofStem globalChallenge publics
    if result then
      passCount := passCount + 1
    else
      failCount := failCount + 1
    allTests := allTests ++ test s!"{airName} proof verifies" result

  IO.println s!"\nResults: {passCount} passed, {failCount} failed out of {ZISK_AIRS.size}"

  lspecIO (.ofList [("Zisk Verifier E2E", [allTests])]) []
