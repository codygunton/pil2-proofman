#!/bin/bash
# Generate Zisk E2E test fixtures (binary proof files) for the Python executable spec.
#
# Usage:
#   ./generate-zisk-test-vectors.sh [--zisk-dir DIR] [--proving-key DIR] [--elf PATH]
#
# This script:
#   1. Runs cargo-zisk rom-setup to prepare ROM data
#   2. Runs cargo-zisk prove (GPU by default) to generate JSON proofs + publics
#   3. Converts JSON proofs to binary (.proof.bin) via json-proof-to-bin.py
#   4. Copies all fixtures to executable-spec/tests/test-data/zisk/
#
# The cargo-zisk binary must be built with --features gpu for GPU proving.
# GPU proving generates 12 AIR proofs in ~3 seconds vs ~17 minutes on CPU.
#
# Prerequisites:
#   - A GPU-enabled cargo-zisk binary (from the zisk-for-spec repo, v0.15.0)
#   - A Zisk proving key (generated by pil2-proofman-js setup)
#   - A Zisk guest ELF (built with cargo-zisk sdk)
#   - CUDA runtime (libcudart.so) available on LD_LIBRARY_PATH
#   - Python environment set up: cd executable-spec && ./setup.sh
#
# Environment:
#   ZISK_DIR        Path to zisk repo with built cargo-zisk (default: ../zisk-for-spec)
#   ZISK_PROVING_KEY Path to proving key directory (default: $ZISK_DIR/provingKey)
#   ZISK_ELF        Path to guest ELF program (default: $ZISK_DIR/witness-computation/rom/zisk.elf)

set -e

ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
EXEC_SPEC_DIR="$ROOT_DIR/executable-spec"
TEST_DATA_DIR="$EXEC_SPEC_DIR/tests/test-data/zisk"

# --- Parse arguments ---
while [[ $# -gt 0 ]]; do
    case "$1" in
        --zisk-dir)   ZISK_DIR="$2"; shift 2 ;;
        --proving-key) ZISK_PROVING_KEY="$2"; shift 2 ;;
        --elf)        ZISK_ELF="$2"; shift 2 ;;
        -h|--help)
            echo "Usage: $0 [--zisk-dir DIR] [--proving-key DIR] [--elf PATH]"
            exit 0 ;;
        *)
            echo "Unknown option: $1" >&2
            exit 1 ;;
    esac
done

# --- Defaults ---
ZISK_DIR="${ZISK_DIR:-$(cd "$ROOT_DIR/../zisk-for-spec" 2>/dev/null && pwd)}"
ZISK_PROVING_KEY="${ZISK_PROVING_KEY:-$ZISK_DIR/provingKey}"
ZISK_ELF="${ZISK_ELF:-$ZISK_DIR/witness-computation/rom/zisk.elf}"
CARGO_ZISK="$ZISK_DIR/target/release/cargo-zisk"

# --- Validate prerequisites ---
echo "=== Generate Zisk Test Vectors ==="
echo ""
echo "Configuration:"
echo "  ZISK_DIR:         $ZISK_DIR"
echo "  ZISK_PROVING_KEY: $ZISK_PROVING_KEY"
echo "  ZISK_ELF:         $ZISK_ELF"
echo "  CARGO_ZISK:       $CARGO_ZISK"
echo ""

errors=0
if [ ! -x "$CARGO_ZISK" ]; then
    echo "ERROR: cargo-zisk not found at $CARGO_ZISK"
    echo "  Build it: cd $ZISK_DIR && cargo build --release -p cargo-zisk"
    errors=1
fi
if [ ! -d "$ZISK_PROVING_KEY" ]; then
    echo "ERROR: Proving key not found at $ZISK_PROVING_KEY"
    errors=1
fi
if [ ! -f "$ZISK_ELF" ]; then
    echo "ERROR: Guest ELF not found at $ZISK_ELF"
    errors=1
fi
if [ $errors -ne 0 ]; then
    exit 1
fi

# --- Set up LD_LIBRARY_PATH ---
RUST_STD_PATH="$(rustc --print sysroot)/lib/rustlib/x86_64-unknown-linux-gnu/lib"
export LD_LIBRARY_PATH="$RUST_STD_PATH${LD_LIBRARY_PATH:+:$LD_LIBRARY_PATH}"
# Intel OneAPI runtime (required for iomp5 threading)
if [ -d "/opt/intel/oneapi/redist/lib" ]; then
    export LD_LIBRARY_PATH="$LD_LIBRARY_PATH:/opt/intel/oneapi/redist/lib"
elif [ -d "/opt/intel/oneapi/compiler/2025.0/lib" ]; then
    export LD_LIBRARY_PATH="$LD_LIBRARY_PATH:/opt/intel/oneapi/compiler/2025.0/lib"
fi

# --- Step 1: ROM setup ---
echo "=== Step 1: ROM setup ==="
ROM_CONST="$ZISK_PROVING_KEY/zisk/Zisk/airs/Rom/air/Rom.const"
if [ -f "$ROM_CONST" ]; then
    echo "  ROM setup already done (found $ROM_CONST), skipping."
else
    "$CARGO_ZISK" rom-setup \
        --elf "$ZISK_ELF" \
        --proving-key "$ZISK_PROVING_KEY" \
        --zisk-path "$ZISK_DIR"
fi
echo ""

# --- Step 2: Generate proofs ---
echo "=== Step 2: Generate proofs ==="
OUTPUT_DIR="$(mktemp -d)"
mkdir -p "$OUTPUT_DIR/proofs"
echo "  Output dir: $OUTPUT_DIR"

# cargo-zisk prove writes JSON proofs. Known cargo-zisk bug: SIGSEGV (exit 139)
# at cleanup after proofs are already saved. We swallow all errors here because
# the proof files are verified in step 3.
# --emulator: use Rust emulator for witness computation (no assembly compilation needed)
# --save-proofs: save per-AIR proofs as JSON (skips VADCOP aggregation/verification)
"$CARGO_ZISK" prove \
    --elf "$ZISK_ELF" \
    --witness-lib "$ZISK_DIR/target/release/libzisk_witness.so" \
    --proving-key "$ZISK_PROVING_KEY" \
    --output-dir "$OUTPUT_DIR" \
    --emulator \
    --save-proofs \
    || true

# Verify proofs were generated
PROOF_COUNT=$(ls "$OUTPUT_DIR/proofs/"*.json 2>/dev/null | wc -l)
if [ "$PROOF_COUNT" -eq 0 ]; then
    echo "ERROR: No JSON proofs generated in $OUTPUT_DIR/proofs/"
    exit 1
fi
echo "  Generated $PROOF_COUNT JSON proofs"
echo ""

# --- Step 3: Convert JSON proofs to binary ---
echo "=== Step 3: Convert JSON proofs to binary ==="
cd "$EXEC_SPEC_DIR"

for json_proof in "$OUTPUT_DIR/proofs/"*.json; do
    filename=$(basename "$json_proof")
    stem="${filename%.json}"
    air_name="${stem%%_*}"

    starkinfo="$ZISK_PROVING_KEY/zisk/Zisk/airs/$air_name/air/$air_name.starkinfo.json"
    if [ ! -f "$starkinfo" ]; then
        echo "  SKIP $stem: starkinfo not found at $starkinfo"
        continue
    fi

    bin_output="$OUTPUT_DIR/proofs/$stem.proof.bin"
    echo "  Converting $stem..."
    uv run python tests/json-proof-to-bin.py \
        --proof-json "$json_proof" \
        --starkinfo "$starkinfo" \
        --output "$bin_output"
done
echo ""

# --- Step 4: Copy fixtures to test-data ---
echo "=== Step 4: Copy fixtures to test-data ==="
mkdir -p "$TEST_DATA_DIR/proofs"

# Copy binary proofs and JSON proofs
for bin_proof in "$OUTPUT_DIR/proofs/"*.proof.bin; do
    [ -f "$bin_proof" ] || continue
    filename=$(basename "$bin_proof")
    cp "$bin_proof" "$TEST_DATA_DIR/proofs/$filename"
    echo "  Copied $filename"
done

for json_proof in "$OUTPUT_DIR/proofs/"*.json; do
    filename=$(basename "$json_proof")
    cp "$json_proof" "$TEST_DATA_DIR/proofs/$filename"
done

# Copy publics and proof_values
if [ -f "$OUTPUT_DIR/publics.json" ]; then
    cp "$OUTPUT_DIR/publics.json" "$TEST_DATA_DIR/publics.json"
    echo "  Copied publics.json"
fi
if [ -f "$OUTPUT_DIR/proof_values.json" ]; then
    cp "$OUTPUT_DIR/proof_values.json" "$TEST_DATA_DIR/proof_values.json"
    echo "  Copied proof_values.json"
fi

# Extract global_challenge from the first JSON proof
first_proof=$(ls "$OUTPUT_DIR/proofs/"*.json 2>/dev/null | head -1)
if [ -n "$first_proof" ]; then
    uv run python -c "
import json, sys
with open('$first_proof') as f:
    p = json.load(f)
gc = p.get('globalChallenge', p.get('global_challenge', []))
if gc:
    json.dump(gc, sys.stdout, indent=4)
    print()
" > "$TEST_DATA_DIR/global_challenge.json" 2>/dev/null || true
    if [ -s "$TEST_DATA_DIR/global_challenge.json" ]; then
        echo "  Extracted global_challenge.json"
    fi
fi

echo ""

# --- Step 5: Verify ---
echo "=== Step 5: Verify ==="
BIN_COUNT=$(ls "$TEST_DATA_DIR/proofs/"*.proof.bin 2>/dev/null | wc -l)
echo "  Binary proofs: $BIN_COUNT"
echo "  Publics: $([ -f "$TEST_DATA_DIR/publics.json" ] && echo 'yes' || echo 'NO')"
echo "  Global challenge: $([ -f "$TEST_DATA_DIR/global_challenge.json" ] && echo 'yes' || echo 'NO')"
echo ""

# Clean up temp dir
rm -rf "$OUTPUT_DIR"

echo "=== Done ==="
echo ""
echo "Test fixtures in: executable-spec/tests/test-data/zisk/"
echo ""
echo "To run Zisk verifier tests:"
echo "  cd executable-spec"
echo "  ZISK_PROVING_KEY=$ZISK_PROVING_KEY ./run-tests.sh -k zisk"
