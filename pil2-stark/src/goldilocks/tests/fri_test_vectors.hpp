#ifndef FRI_TEST_VECTORS_HPP
#define FRI_TEST_VECTORS_HPP

#include "goldilocks_base_field.hpp"
#include <vector>
#include <array>
#include <cstdint>

/**
 * Test vectors for FRI PCS unit testing
 *
 * These vectors are designed to verify:
 * 1. Single FRI fold step correctness
 * 2. Multi-step FRI folding
 * 3. Complete prove/verify round-trip
 *
 * The expected outputs were generated by running the existing FRI implementation
 * with known inputs and capturing the results.
 */
namespace FriTestVectors {

// ===========================================================================
// Pinning vectors - These MUST NOT change after refactoring
// If they change, the FRI implementation has regressed
// ===========================================================================

namespace Pinning {
    /**
     * Fixed input polynomial for pinning test (8 cubic extension elements = 24 Goldilocks elements)
     * This is a small polynomial suitable for testing the fold operation
     */
    constexpr std::array<uint64_t, 24> INPUT_POLY_24 = {
        // Element 0 (cubic extension: [a, b, c])
        0x0000000000000001ULL, 0x0000000000000002ULL, 0x0000000000000003ULL,
        // Element 1
        0x0000000000000004ULL, 0x0000000000000005ULL, 0x0000000000000006ULL,
        // Element 2
        0x0000000000000007ULL, 0x0000000000000008ULL, 0x0000000000000009ULL,
        // Element 3
        0x000000000000000AULL, 0x000000000000000BULL, 0x000000000000000CULL,
        // Element 4
        0x000000000000000DULL, 0x000000000000000EULL, 0x000000000000000FULL,
        // Element 5
        0x0000000000000010ULL, 0x0000000000000011ULL, 0x0000000000000012ULL,
        // Element 6
        0x0000000000000013ULL, 0x0000000000000014ULL, 0x0000000000000015ULL,
        // Element 7
        0x0000000000000016ULL, 0x0000000000000017ULL, 0x0000000000000018ULL
    };

    /**
     * Fixed challenge for pinning test (3 Goldilocks elements for cubic extension)
     */
    constexpr std::array<uint64_t, 3> CHALLENGE_3 = {
        0x123456789ABCDEF0ULL,
        0xFEDCBA9876543210ULL,
        0x1111111111111111ULL
    };

    /**
     * Expected output after single fold step (4 cubic extension elements = 12 Goldilocks elements)
     * TO BE FILLED IN by the vector capture utility
     *
     * Input: 8 elements (n_bits=3), Challenge: CHALLENGE_3
     * Output: 4 elements (n_bits=2)
     *
     * These values will be populated when running generate_fri_vectors
     */
    constexpr std::array<uint64_t, 12> EXPECTED_FOLDED_12 = {
        // Placeholder - will be filled by capture utility
        0ULL, 0ULL, 0ULL, 0ULL, 0ULL, 0ULL,
        0ULL, 0ULL, 0ULL, 0ULL, 0ULL, 0ULL
    };
}

// ===========================================================================
// Small polynomial test (degree 8) for basic fold verification
// ===========================================================================

namespace SmallPoly {
    constexpr uint64_t N_BITS = 3;  // 2^3 = 8 elements
    constexpr uint64_t DEGREE = 8;

    /**
     * Get a simple polynomial with known structure
     * poly[i] = i + 1 for each field extension component
     */
    inline std::vector<Goldilocks::Element> get_polynomial() {
        std::vector<Goldilocks::Element> poly(DEGREE * 3);
        for (uint64_t i = 0; i < DEGREE * 3; i++) {
            poly[i] = Goldilocks::fromU64(i + 1);
        }
        return poly;
    }

    /**
     * Get a challenge for folding
     */
    inline std::array<Goldilocks::Element, 3> get_challenge() {
        return {
            Goldilocks::fromU64(0x123456789ABCDEF0ULL),
            Goldilocks::fromU64(0xFEDCBA9876543210ULL),
            Goldilocks::fromU64(0x1111111111111111ULL)
        };
    }
}

// ===========================================================================
// Medium polynomial test (degree 64) for multi-step FRI
// ===========================================================================

namespace MediumPoly {
    constexpr uint64_t N_BITS = 6;  // 2^6 = 64 elements
    constexpr uint64_t DEGREE = 64;
    constexpr std::array<uint64_t, 3> FRI_STEPS = {6, 4, 2};

    /**
     * Get a polynomial with values derived from index
     * This creates reproducible test data
     */
    inline std::vector<Goldilocks::Element> get_polynomial() {
        std::vector<Goldilocks::Element> poly(DEGREE * 3);
        for (uint64_t i = 0; i < DEGREE * 3; i++) {
            // Use a simple deterministic formula
            uint64_t val = ((i + 1) * 0x9E3779B97F4A7C15ULL) % Goldilocks::GOLDILOCKS_PRIME;
            poly[i] = Goldilocks::fromU64(val);
        }
        return poly;
    }

    /**
     * Get challenges for each FRI step
     */
    inline std::vector<Goldilocks::Element> get_challenges() {
        std::vector<Goldilocks::Element> challenges(FRI_STEPS.size() * 3);

        // Step 0 challenge
        challenges[0] = Goldilocks::fromU64(0xAAAAAAAAAAAAAAAAULL);
        challenges[1] = Goldilocks::fromU64(0x5555555555555555ULL);
        challenges[2] = Goldilocks::fromU64(0x1234567812345678ULL);

        // Step 1 challenge
        challenges[3] = Goldilocks::fromU64(0xBBBBBBBBBBBBBBBBULL);
        challenges[4] = Goldilocks::fromU64(0x6666666666666666ULL);
        challenges[5] = Goldilocks::fromU64(0x2345678923456789ULL);

        // Step 2 challenge
        challenges[6] = Goldilocks::fromU64(0xCCCCCCCCCCCCCCCCULL);
        challenges[7] = Goldilocks::fromU64(0x7777777777777777ULL);
        challenges[8] = Goldilocks::fromU64(0x3456789A3456789AULL);

        return challenges;
    }
}

// ===========================================================================
// Helper functions for test vector generation
// ===========================================================================

/**
 * Print polynomial as hex values (for vector capture)
 */
inline void print_polynomial(const Goldilocks::Element* poly, uint64_t num_elements, const char* name) {
    printf("constexpr std::array<uint64_t, %lu> %s = {\n", num_elements, name);
    for (uint64_t i = 0; i < num_elements; i++) {
        printf("    0x%016lxULL%s\n",
               Goldilocks::toU64(poly[i]),
               (i + 1 < num_elements) ? "," : "");
    }
    printf("};\n");
}

/**
 * Compare polynomial with expected values
 * Returns true if all elements match
 */
inline bool compare_polynomial(const Goldilocks::Element* actual,
                               const uint64_t* expected,
                               uint64_t num_elements) {
    for (uint64_t i = 0; i < num_elements; i++) {
        if (Goldilocks::toU64(actual[i]) != expected[i]) {
            return false;
        }
    }
    return true;
}

} // namespace FriTestVectors

#endif // FRI_TEST_VECTORS_HPP
