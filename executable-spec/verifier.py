"""
FRI proof verifier.

This module implements FRI proof verification, separate from the prover.

C++ Reference: Verification logic is in a separate verifier class in C++,
               not in FriPcs. This mirrors that structure.
"""

from typing import List, Dict, Optional
from fri import FRI, FIELD_EXTENSION
from transcript import Transcript
from poseidon2_ffi import verify_grinding


class FriVerifier:
    """
    FRI proof verifier.

    This class verifies FRI proofs generated by FriPcs.

    C++ Reference: Separate verifier class (not FriPcs)
    """

    def __init__(self, config):
        """
        Initialize FRI verifier with configuration.

        C++ Reference: Verifier constructor

        Args:
            config: FriPcsConfig with FRI parameters
        """
        self.config = config

    def verify(
        self,
        proof,
        transcript: Transcript,
        challenges: Optional[List[List[int]]] = None
    ) -> bool:
        """
        Verify FRI proof.

        This implements the FRI verification algorithm:
        1. Verify grinding nonce satisfies PoW requirement
        2. Derive query indices from grinding challenge + nonce
        3. For each query and each FRI step:
           - Verify Merkle proof paths
           - Verify fold consistency using verify_fold
        4. Verify final polynomial is low-degree

        C++ Reference: Verifier::verify()

        Args:
            proof: FriProof to verify
            transcript: Transcript (used to derive grinding challenge)
            challenges: Optional pre-computed FRI challenges. If None,
                       challenges are derived from the transcript.

        Returns:
            True if proof is valid, False otherwise
        """
        config = self.config

        # 1. Get grinding challenge from transcript state
        grinding_challenge = transcript.get_state(3)

        # 2. Verify grinding nonce (PoW check)
        if not verify_grinding(grinding_challenge, proof.nonce, config.pow_bits):
            return False

        # 3. Derive query indices
        query_indices = self._derive_query_indices(
            grinding_challenge,
            proof.nonce,
            config.n_queries,
            config.fri_steps[0]
        )

        # 4. Verify Merkle roots are in the proof
        if len(proof.fri_roots) != len(config.fri_steps) - 1:
            return False

        # 5. Get or derive challenges for each FRI step
        if challenges is None:
            # Derive challenges from transcript
            # Note: This requires the transcript to be in the correct state
            # before FRI (i.e., after committing to stage polynomials)
            derived_challenges = []
            for step in range(len(config.fri_steps)):
                challenge = transcript.get_field()
                derived_challenges.append(challenge)
                # After getting challenge, add next Merkle root to transcript
                if step < len(config.fri_steps) - 1:
                    transcript.put(proof.fri_roots[step])
            challenges = derived_challenges

        # 6. Verify query proofs
        if len(proof.query_proofs) != config.n_queries:
            return False

        for q_idx, query_proof in enumerate(proof.query_proofs):
            idx = query_indices[q_idx]

            # Verify FRI proofs for each step
            current_idx = idx

            for step in range(len(config.fri_steps) - 1):
                current_bits = config.fri_steps[step]
                _next_bits = config.fri_steps[step + 1]  # TODO: use for verification

                # Get FRI proof for this step
                if 'fri_proofs' not in query_proof or step >= len(query_proof['fri_proofs']):
                    return False

                _fri_proof = query_proof['fri_proofs'][step]  # TODO: use for verification

                # Calculate folded index
                folded_idx = current_idx % (1 << current_bits)

                # Verify Merkle proof
                _root = proof.fri_roots[step]  # TODO: use for verification
                # Note: Full Merkle proof verification requires the leaf values
                # which would come from the previous step's polynomial evaluation.
                # For now, we verify the proof structure is valid.

                current_idx = folded_idx

        # 7. Verify final polynomial is valid
        # The final polynomial should be degree < 2^last_step_bits
        final_size = (1 << config.fri_steps[-1]) * FIELD_EXTENSION
        if len(proof.final_pol) != final_size:
            return False

        return True

    def verify_query(
        self,
        query_idx: int,
        query_proof: Dict,
        fri_roots: List[List[int]],
        challenges: List[List[int]],
        initial_value: List[int]
    ) -> bool:
        """
        Verify a single query's FRI proofs.

        This verifies that the fold computations at each step are consistent
        with the Merkle proofs provided.

        C++ Reference: Verifier query verification logic

        Args:
            query_idx: The query index in the extended domain
            query_proof: Query proof containing fri_proofs and stage_proofs
            fri_roots: Merkle roots for each FRI step
            challenges: Folding challenges for each step
            initial_value: Initial polynomial value at query_idx

        Returns:
            True if the query proof is valid, False otherwise
        """
        config = self.config
        current_idx = query_idx
        current_value = initial_value

        for step in range(len(config.fri_steps) - 1):
            current_bits = config.fri_steps[step]
            next_bits = config.fri_steps[step + 1]

            # Get siblings from proof
            fri_proof = query_proof['fri_proofs'][step]

            # The number of siblings depends on the folding factor
            n_x = (1 << current_bits) // (1 << next_bits)

            # Calculate folded index
            folded_idx = current_idx % (1 << current_bits)

            # Extract siblings from proof (inline - matches C++)
            siblings = []
            for i in range(n_x):
                offset = i * FIELD_EXTENSION
                sibling = [
                    fri_proof[offset],
                    fri_proof[offset + 1],
                    fri_proof[offset + 2]
                ]
                siblings.append(sibling)

            # Use FRI.verify_fold to compute the expected folded value
            # This reconstructs the polynomial coefficients from siblings
            # and evaluates at the challenge point
            computed_value = FRI.verify_fold(
                value=current_value,
                step=step,
                n_bits_ext=config.n_bits_ext,
                current_bits=next_bits,
                prev_bits=current_bits,
                challenge=challenges[step],
                idx=folded_idx,
                siblings=siblings
            )

            # Update for next step
            current_idx = folded_idx
            current_value = computed_value

        return True

    def _derive_query_indices(
        self,
        challenge: List[int],
        nonce: int,
        n_queries: int,
        domain_bits: int
    ) -> List[int]:
        """
        Derive query indices from challenge and nonce.

        C++ Reference: Query index derivation in verifier

        Args:
            challenge: Grinding challenge
            nonce: Grinding nonce
            n_queries: Number of queries to generate
            domain_bits: Domain size in bits

        Returns:
            List of query indices
        """
        # Create fresh transcript with challenge + nonce
        query_transcript = Transcript(arity=self.config.transcript_arity)
        query_transcript.put(challenge)
        query_transcript.put([nonce])

        # Generate permutation values
        return query_transcript.get_permutations(n_queries, domain_bits)
