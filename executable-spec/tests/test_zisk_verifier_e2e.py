"""End-to-end tests for Zisk STARK proof verification.

Tests that the Python verifier correctly verifies proofs generated by
the C++ prover for Zisk zkVM AIRs. Each test loads a binary proof from
test-data/zisk/proofs/, the corresponding starkinfo and verkey from
the Zisk proving key, and verifies the proof passes stark_verify().

Requires:
    - Binary proof fixtures in tests/test-data/zisk/proofs/*.proof.bin
    - publics.json and global_challenge.json in tests/test-data/zisk/
"""

import json
from pathlib import Path

import numpy as np
import pytest

from protocol.air_config import AirConfig
from protocol.proof import from_bytes_full
from protocol.verifier import stark_verify
from tests.conftest import ZISK_PROVING_KEY

TEST_DATA_DIR = Path(__file__).parent / "test-data" / "zisk"

# AIR name -> (proof filename stem)
# Derived from cargo-zisk prove output filenames: {AIRName}_{instanceId}.json
# Generated from Fibonacci(10) guest program on zisk-for-spec v0.15.0 CPU prover.
# All 12 AIRs produce valid proofs (including Rom, which was previously xfail
# with the old ELF/fork). No Arith AIR because Fibonacci doesn't use it.
ZISK_AIR_PARAMS = [
    pytest.param("Main", "Main_0"),
    pytest.param("Rom", "Rom_1"),
    pytest.param("MemAlign", "MemAlign_2"),
    pytest.param("RomData", "RomData_3"),
    pytest.param("InputData", "InputData_4"),
    pytest.param("Mem", "Mem_5"),
    pytest.param("BinaryExtension", "BinaryExtension_6"),
    pytest.param("BinaryAdd", "BinaryAdd_7"),
    pytest.param("Binary", "Binary_8"),
    pytest.param("SpecifiedRanges", "SpecifiedRanges_9"),
    pytest.param("VirtualTable0", "VirtualTable0_10"),
    pytest.param("VirtualTable1", "VirtualTable1_11"),
]


def _get_proving_key_dir() -> Path:
    """Get Zisk proving key directory."""
    return ZISK_PROVING_KEY


def _load_starkinfo_path(pk_dir: Path, air_name: str) -> Path:
    """Get starkinfo.json path for a Zisk AIR."""
    return pk_dir / "zisk" / "Zisk" / "airs" / air_name / "air" / f"{air_name}.starkinfo.json"


def _load_verkey(pk_dir: Path, air_name: str) -> list[int]:
    """Load verkey (Merkle root of const tree) from proving key."""
    verkey_path = pk_dir / "zisk" / "Zisk" / "airs" / air_name / "air" / f"{air_name}.verkey.json"
    with open(verkey_path) as f:
        return json.load(f)


def _load_publics() -> np.ndarray:
    """Load publics from test fixture."""
    publics_path = TEST_DATA_DIR / "publics.json"
    with open(publics_path) as f:
        return np.array([int(v) for v in json.load(f)], dtype=np.uint64)


def _load_global_challenge() -> np.ndarray:
    """Load global_challenge from test fixture."""
    gc_path = TEST_DATA_DIR / "global_challenge.json"
    with open(gc_path) as f:
        return np.array([int(v) for v in json.load(f)], dtype=np.uint64)


class TestZiskVerifierE2E:
    """End-to-end Zisk verifier tests."""

    @pytest.mark.parametrize("air_name,proof_stem", ZISK_AIR_PARAMS)
    def test_verify_zisk_proof(self, air_name: str, proof_stem: str) -> None:
        """Test that stark_verify returns True for valid Zisk proofs."""
        pk_dir = _get_proving_key_dir()

        starkinfo_path = _load_starkinfo_path(pk_dir, air_name)
        air_config = AirConfig.from_starkinfo(str(starkinfo_path))
        stark_info = air_config.stark_info

        bin_path = TEST_DATA_DIR / "proofs" / f"{proof_stem}.proof.bin"
        with open(bin_path, "rb") as f:
            proof_bytes = f.read()

        proof = from_bytes_full(proof_bytes, stark_info)
        verkey = _load_verkey(pk_dir, air_name)
        publics = _load_publics()
        global_challenge = _load_global_challenge()

        result = stark_verify(
            proof=proof,
            air_config=air_config,
            verkey=verkey,
            global_challenge=global_challenge,
            publics=publics,
        )

        assert result is True, f"Valid proof for {air_name} should verify"


if __name__ == "__main__":
    pytest.main([__file__, "-v", "-s"])
