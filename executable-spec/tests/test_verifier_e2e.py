"""End-to-end tests for STARK proof verification.

Tests that the Python verifier correctly verifies proofs generated by
the Python prover. This validates the complete STARK verification flow
including Merkle tree verification.
"""

from pathlib import Path
from typing import Any

import numpy as np
import pytest

from primitives.field import FF
from primitives.ntt import NTT
from primitives.transcript import Transcript
from protocol.air_config import AirConfig
from protocol.stark_info import StarkInfo
from protocol.verifier import stark_verify

TEST_DATA_DIR = Path(__file__).parent / "test-data"

# AIR configurations (same as test_stark_e2e.py)
AIR_CONFIGS = {
    'simple': {
        'test_vector': 'simple-left.json',
        'starkinfo': '../../pil2-components/test/simple/build/provingKey/build/Simple/airs/SimpleLeft/air/SimpleLeft.starkinfo.json',
        'expressions_bin': '../../pil2-components/test/simple/build/provingKey/build/Simple/airs/SimpleLeft/air/SimpleLeft.bin',
    },
    'lookup': {
        'test_vector': 'lookup2-12.json',
        'starkinfo': '../../pil2-components/test/lookup/build/provingKey/lookup/Lookup/airs/Lookup2_12/air/Lookup2_12.starkinfo.json',
        'expressions_bin': '../../pil2-components/test/lookup/build/provingKey/lookup/Lookup/airs/Lookup2_12/air/Lookup2_12.bin',
    },
    'permutation': {
        'test_vector': 'permutation1-6.json',
        'starkinfo': '../../pil2-components/test/permutation/build/provingKey/permutation/Permutation/airs/Permutation1_6/air/Permutation1_6.starkinfo.json',
        'expressions_bin': '../../pil2-components/test/permutation/build/provingKey/permutation/Permutation/airs/Permutation1_6/air/Permutation1_6.bin',
    },
}


def load_test_vectors(air_name: str) -> dict[str, Any] | None:
    """Load test vectors for an AIR."""
    import json
    config = AIR_CONFIGS.get(air_name)
    if not config:
        return None

    test_vector_path = TEST_DATA_DIR / config['test_vector']
    if not test_vector_path.exists():
        return None

    with open(test_vector_path) as f:
        return json.load(f)


def load_air_config(air_name: str) -> AirConfig | None:
    """Load AirConfig for an AIR."""
    config = AIR_CONFIGS.get(air_name)
    if not config:
        return None

    base_dir = Path(__file__).parent
    starkinfo_path = base_dir / config['starkinfo']

    if not starkinfo_path.exists():
        return None

    return AirConfig.from_starkinfo(str(starkinfo_path))


def create_fresh_transcript(stark_info: StarkInfo, vectors: dict) -> Transcript:
    """Create a fresh transcript with global_challenge (if any)."""
    transcript = Transcript(
        arity=stark_info.stark_struct.transcript_arity,
        custom=stark_info.stark_struct.merkle_tree_custom
    )

    global_challenge = vectors['inputs'].get('global_challenge', [])
    if global_challenge:
        transcript.put(global_challenge)

    return transcript


def create_buffers_from_vectors(
    stark_info: StarkInfo, vectors: dict
) -> tuple[np.ndarray, np.ndarray, np.ndarray | None]:
    """Create explicit buffers from test vectors.

    Returns:
        Tuple of (const_pols, const_pols_extended, public_inputs)
    """
    inputs = vectors['inputs']

    N = 1 << stark_info.stark_struct.n_bits
    N_ext = 1 << stark_info.stark_struct.n_bits_ext
    n_constants = inputs['n_constants']

    # Convert constant polynomials
    const_pols = FF(inputs['const_pols'])

    # Extend constant polynomials
    ntt = NTT(N)
    const_pols_extended = ntt.extend_pol(const_pols, N_ext, N, n_constants)

    # Extract public_inputs (if any)
    public_inputs = None
    if stark_info.n_publics > 0 and 'public_inputs' in inputs:
        public_inputs = np.array(inputs['public_inputs'], dtype=np.uint64)

    return (
        np.asarray(const_pols, dtype=np.uint64),
        np.asarray(const_pols_extended, dtype=np.uint64),
        public_inputs
    )


class TestVerifierE2E:
    """End-to-end verifier tests."""

    @pytest.mark.parametrize("air_name", ['simple', 'lookup', 'permutation'])
    def test_verify_valid_proof(self, air_name: str) -> None:
        """Test that stark_verify returns True for valid proofs.

        Loads pre-generated binary proofs from test-data/*.proof.bin and verifies them.
        This tests the verifier in isolation without running the prover.
        """
        from protocol.proof import from_bytes_full
        from protocol.stages import Starks

        air_config = load_air_config(air_name)
        if air_config is None:
            pytest.skip(f"Setup files not found for {air_name}")

        stark_info = air_config.stark_info

        # Load binary proof file
        config = AIR_CONFIGS.get(air_name)
        bin_filename = config['test_vector'].replace('.json', '.proof.bin')
        bin_path = TEST_DATA_DIR / bin_filename

        if not bin_path.exists():
            pytest.skip(f"Binary proof not found: {bin_path}")

        with open(bin_path, 'rb') as f:
            proof_bytes = f.read()

        # Deserialize binary proof to STARKProof
        proof = from_bytes_full(proof_bytes, stark_info)

        # Load test vectors for verkey and global_challenge
        vectors = load_test_vectors(air_name)
        if vectors is None:
            pytest.skip(f"Test vectors not found for {air_name}")

        const_pols, const_pols_extended, public_inputs = create_buffers_from_vectors(stark_info, vectors)
        starks = Starks(air_config)
        verkey = starks.build_const_tree(const_pols_extended)

        global_challenge = np.array(vectors['inputs']['global_challenge'], dtype=np.uint64)

        # Verify the proof
        print(f"\nVerifying {air_name} proof from {bin_filename}...")
        result = stark_verify(
            proof=proof,
            air_config=air_config,
            verkey=verkey,
            global_challenge=global_challenge,
            publics=public_inputs,
        )

        assert result is True, f"Valid proof for {air_name} should verify"

    @pytest.mark.parametrize("air_name", ['simple'])
    def test_verify_corrupted_root_fails(self, air_name: str) -> None:
        """Test that stark_verify returns False for proofs with corrupted roots.

        Loads a valid binary proof, corrupts root1, and verifies it fails.
        """
        from protocol.proof import from_bytes_full
        from protocol.stages import Starks

        air_config = load_air_config(air_name)
        if air_config is None:
            pytest.skip(f"Setup files not found for {air_name}")

        stark_info = air_config.stark_info

        # Load binary proof file
        config = AIR_CONFIGS.get(air_name)
        bin_filename = config['test_vector'].replace('.json', '.proof.bin')
        bin_path = TEST_DATA_DIR / bin_filename

        if not bin_path.exists():
            pytest.skip(f"Binary proof not found: {bin_path}")

        with open(bin_path, 'rb') as f:
            proof_bytes = f.read()

        # Deserialize binary proof to STARKProof
        proof = from_bytes_full(proof_bytes, stark_info)

        # Load test vectors for verkey and global_challenge
        vectors = load_test_vectors(air_name)
        if vectors is None:
            pytest.skip(f"Test vectors not found for {air_name}")

        const_pols, const_pols_extended, public_inputs = create_buffers_from_vectors(stark_info, vectors)
        starks = Starks(air_config)
        verkey = starks.build_const_tree(const_pols_extended)
        global_challenge = np.array(vectors['inputs']['global_challenge'], dtype=np.uint64)

        # Corrupt root1 (roots[0])
        proof.roots[0] = [0, 0, 0, 0]  # Invalid root

        # Verify should fail
        result = stark_verify(
            proof=proof,
            air_config=air_config,
            verkey=verkey,
            global_challenge=global_challenge,
            publics=public_inputs,
        )

        assert result is False, "Proof with corrupted root1 should fail verification"


if __name__ == "__main__":
    pytest.main([__file__, "-v", "-s"])
