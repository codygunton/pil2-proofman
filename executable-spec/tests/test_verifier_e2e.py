"""End-to-end tests for STARK proof verification.

Tests that the Python verifier correctly verifies proofs generated by
the Python prover. This validates the complete STARK verification flow
including Merkle tree verification.
"""

import pytest
import numpy as np
from pathlib import Path
from typing import Dict, Any, Optional

from primitives.field import FF
from protocol.proof_context import ProofContext
from protocol.setup_ctx import SetupCtx
from primitives.transcript import Transcript
from protocol.verifier import stark_verify


TEST_DATA_DIR = Path(__file__).parent / "test-data"

# AIR configurations (same as test_stark_e2e.py)
AIR_CONFIGS = {
    'simple': {
        'test_vector': 'simple-left.json',
        'starkinfo': '../../pil2-components/test/simple/build/provingKey/build/Simple/airs/SimpleLeft/air/SimpleLeft.starkinfo.json',
        'expressions_bin': '../../pil2-components/test/simple/build/provingKey/build/Simple/airs/SimpleLeft/air/SimpleLeft.bin',
    },
    'lookup': {
        'test_vector': 'lookup2-12.json',
        'starkinfo': '../../pil2-components/test/lookup/build/provingKey/lookup/Lookup/airs/Lookup2_12/air/Lookup2_12.starkinfo.json',
        'expressions_bin': '../../pil2-components/test/lookup/build/provingKey/lookup/Lookup/airs/Lookup2_12/air/Lookup2_12.bin',
    },
    'permutation': {
        'test_vector': 'permutation1-6.json',
        'starkinfo': '../../pil2-components/test/permutation/build/provingKey/permutation/Permutation/airs/Permutation1_6/air/Permutation1_6.starkinfo.json',
        'expressions_bin': '../../pil2-components/test/permutation/build/provingKey/permutation/Permutation/airs/Permutation1_6/air/Permutation1_6.bin',
    },
}


def load_test_vectors(air_name: str) -> Optional[Dict[str, Any]]:
    """Load test vectors for an AIR."""
    import json
    config = AIR_CONFIGS.get(air_name)
    if not config:
        return None

    test_vector_path = TEST_DATA_DIR / config['test_vector']
    if not test_vector_path.exists():
        return None

    with open(test_vector_path) as f:
        return json.load(f)


def load_setup_ctx(air_name: str) -> Optional[SetupCtx]:
    """Load SetupCtx for an AIR."""
    config = AIR_CONFIGS.get(air_name)
    if not config:
        return None

    base_dir = Path(__file__).parent
    starkinfo_path = base_dir / config['starkinfo']
    expressions_bin_path = base_dir / config['expressions_bin']

    if not starkinfo_path.exists() or not expressions_bin_path.exists():
        return None

    return SetupCtx.from_files(str(starkinfo_path), str(expressions_bin_path))


def create_fresh_transcript(stark_info, vectors: dict) -> Transcript:
    """Create a fresh transcript with global_challenge (if any)."""
    transcript = Transcript(
        arity=stark_info.starkStruct.transcriptArity,
        custom=stark_info.starkStruct.merkleTreeCustom
    )

    global_challenge = vectors['inputs'].get('global_challenge', [])
    if global_challenge:
        transcript.put(global_challenge)

    return transcript


def create_params_from_vectors(stark_info, vectors: dict) -> ProofContext:
    """Create ProofContext initialized from test vectors."""
    from primitives.ntt import NTT

    inputs = vectors['inputs']

    N = 1 << stark_info.starkStruct.nBits
    N_ext = 1 << stark_info.starkStruct.nBitsExt
    n_constants = inputs['n_constants']

    # Calculate total trace buffer size
    trace_size = 0
    for section in ['cm1', 'cm2', 'cm3']:
        if section in stark_info.mapSectionsN:
            offset = stark_info.mapOffsets.get((section, False), 0)
            size = N * stark_info.mapSectionsN[section]
            trace_size = max(trace_size, offset + size)

    # Allocate trace and copy witness
    witness_trace_data = FF(inputs['witness_trace'])
    trace = FF.Zeros(trace_size)
    trace[:len(witness_trace_data)] = witness_trace_data

    # Convert constant polynomials
    const_pols = FF(inputs['const_pols'])

    # Extend constant polynomials
    ntt = NTT(N)
    const_pols_extended = ntt.extend_pol(const_pols, N_ext, N, n_constants)

    # Allocate challenges buffer
    challenges = np.zeros(len(stark_info.challengesMap) * 3, dtype=np.uint64)

    params = ProofContext(
        trace=trace,
        auxTrace=np.zeros(stark_info.mapTotalN, dtype=np.uint64),
        publicInputs=FF.Zeros(max(1, stark_info.nPublics)),
        challenges=challenges,
        evals=np.zeros(len(stark_info.evMap) * 3, dtype=np.uint64),
        airValues=np.zeros(max(1, stark_info.airValuesSize * 3), dtype=np.uint64),
        airgroupValues=np.zeros(max(1, stark_info.airgroupValuesSize * 3), dtype=np.uint64),
        constPols=const_pols,
        constPolsExtended=const_pols_extended,
    )

    return params


class TestVerifierE2E:
    """End-to-end verifier tests."""

    @pytest.mark.parametrize("air_name", ['simple', 'lookup', 'permutation'])
    def test_verify_valid_proof(self, air_name):
        """Test that stark_verify returns True for valid proofs.

        Loads pre-generated binary proofs from test-data/*.proof.bin and verifies them.
        This tests the verifier in isolation without running the prover.
        """
        from protocol.proof import from_bytes_full_to_jproof
        from protocol.stages import Starks

        setup_ctx = load_setup_ctx(air_name)
        if setup_ctx is None:
            pytest.skip(f"Setup files not found for {air_name}")

        stark_info = setup_ctx.stark_info

        # Load binary proof file
        config = AIR_CONFIGS.get(air_name)
        bin_filename = config['test_vector'].replace('.json', '.proof.bin')
        bin_path = TEST_DATA_DIR / bin_filename

        if not bin_path.exists():
            pytest.skip(f"Binary proof not found: {bin_path}")

        with open(bin_path, 'rb') as f:
            proof_bytes = f.read()

        # Deserialize binary proof to jproof format
        jproof = from_bytes_full_to_jproof(proof_bytes, stark_info)

        # Load test vectors for verkey and global_challenge
        vectors = load_test_vectors(air_name)
        if vectors is None:
            pytest.skip(f"Test vectors not found for {air_name}")

        params = create_params_from_vectors(stark_info, vectors)
        starks = Starks(setup_ctx)
        verkey = starks.build_const_tree(params.constPolsExtended)

        global_challenge = np.array(vectors['inputs']['global_challenge'], dtype=np.uint64)

        # Verify the proof
        print(f"\nVerifying {air_name} proof from {bin_filename}...")
        result = stark_verify(
            jproof=jproof,
            setup_ctx=setup_ctx,
            verkey=verkey,
            global_challenge=global_challenge,
            publics=params.publicInputs,
        )

        assert result is True, f"Valid proof for {air_name} should verify"

    @pytest.mark.parametrize("air_name", ['simple'])
    def test_verify_corrupted_root_fails(self, air_name):
        """Test that stark_verify returns False for proofs with corrupted roots.

        Loads a valid binary proof, corrupts root1, and verifies it fails.
        """
        from protocol.proof import from_bytes_full_to_jproof
        from protocol.stages import Starks

        setup_ctx = load_setup_ctx(air_name)
        if setup_ctx is None:
            pytest.skip(f"Setup files not found for {air_name}")

        stark_info = setup_ctx.stark_info

        # Load binary proof file
        config = AIR_CONFIGS.get(air_name)
        bin_filename = config['test_vector'].replace('.json', '.proof.bin')
        bin_path = TEST_DATA_DIR / bin_filename

        if not bin_path.exists():
            pytest.skip(f"Binary proof not found: {bin_path}")

        with open(bin_path, 'rb') as f:
            proof_bytes = f.read()

        # Deserialize binary proof to jproof format
        jproof = from_bytes_full_to_jproof(proof_bytes, stark_info)

        # Load test vectors for verkey and global_challenge
        vectors = load_test_vectors(air_name)
        if vectors is None:
            pytest.skip(f"Test vectors not found for {air_name}")

        params = create_params_from_vectors(stark_info, vectors)
        starks = Starks(setup_ctx)
        verkey = starks.build_const_tree(params.constPolsExtended)
        global_challenge = np.array(vectors['inputs']['global_challenge'], dtype=np.uint64)

        # Corrupt root1
        jproof_corrupted = dict(jproof)
        jproof_corrupted['root1'] = [0, 0, 0, 0]  # Invalid root

        # Verify should fail
        result = stark_verify(
            jproof=jproof_corrupted,
            setup_ctx=setup_ctx,
            verkey=verkey,
            global_challenge=global_challenge,
            publics=params.publicInputs,
        )

        assert result is False, "Proof with corrupted root1 should fail verification"


if __name__ == "__main__":
    pytest.main([__file__, "-v", "-s"])
