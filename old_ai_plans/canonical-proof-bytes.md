# Canonical Proof Byte Equivalence Implementation Plan

## Executive Summary

**Problem**: The current `test_full_proof_matches` compares proofs structurally. If the proof structure changes, tests might silently miss mismatches.

**Solution**: Capture the raw `proofBuffer` (uint64 array from `proof2pointer()`) as a binary file from C++, then compare it byte-for-byte with Python's serialized proof.

### Data Flow

```
C++ Prover                              Python Prover
    │                                        │
    ▼                                        ▼
proof2pointer(proofBuffer)              proof.to_bytes()
    │                                        │
    ▼                                        ▼
write to .proof.bin ────────────────► assert bytes == file contents
```

### Expected Outcomes
- C++ outputs `{name}.proof.bin` containing raw uint64 array
- Python `STARKProof.to_bytes()` produces identical bytes
- Test compares bytes directly with zero parsing

---

## Implementation Tasks

### Visual Dependency Tree

```
pil2-stark/src/starkpil/
└── gen_proof.hpp                    (Task #1: write proofBuffer to .bin file)

generate-test-vectors.sh             (Task #1: pass bin output path to C++)

executable-spec/
├── protocol/
│   └── proof.py                     (Task #2: implement to_bytes())
│
└── tests/
    ├── test-data/
    │   ├── simple-left.proof.bin    (generated by Task #1)
    │   ├── lookup2-12.proof.bin     (generated by Task #1)
    │   └── permutation1-6.proof.bin (generated by Task #1)
    │
    └── test_stark_e2e.py            (Task #3: add byte comparison test)
```

### Execution Plan

#### Task #1: Capture raw proofBuffer as binary file from C++

- [ ] **Modify `gen_proof.hpp`** to write binary file
  - File: `pil2-stark/src/starkpil/gen_proof.hpp`
  - Location: After line 533 (`proof.proof.proof2pointer(proofBuffer)`)
  - Add binary file output alongside existing JSON output:
    ```cpp
    // Write binary proof (raw uint64 array)
    if(!proofBinFile.empty()) {
        std::ofstream binOut(proofBinFile, std::ios::binary);
        binOut.write(reinterpret_cast<const char*>(proofBuffer),
                     setupCtx.starkInfo.proofSize * sizeof(uint64_t));
    }
    ```
  - Add `proofBinFile` parameter to `genProof()` function signature

- [ ] **Update FFI and Rust bindings** to pass binary output path
  - Files: `pil2-stark/src/api/starks_api.cpp`, `provers/starks-lib-c/src/ffi_starks.rs`
  - Add parameter for binary proof output path

- [ ] **Update `generate-test-vectors.sh`** to request binary output
  - Pass additional flag/path for `.proof.bin` output
  - Copy generated `.proof.bin` files to `executable-spec/tests/test-data/`

#### Task #2: Implement `STARKProof.to_bytes()` in Python

- [ ] **Add `to_bytes()` method** to `STARKProof` class
  - File: `executable-spec/protocol/proof.py`
  - Must match C++ `proof2pointer()` layout exactly (see layout below)
  - Returns `bytes` (little-endian packed uint64 array)

  ```python
  def to_bytes(self, stark_info) -> bytes:
      """Serialize proof to canonical binary format matching C++ proof2pointer()."""
      import struct
      values = []

      # 1. airgroupValues (FIELD_EXTENSION per entry)
      for val in self.airgroup_values:
          values.extend(val[:FIELD_EXTENSION])

      # 2. airValues (FIELD_EXTENSION per entry)
      for val in self.air_values:
          values.extend(val[:FIELD_EXTENSION])

      # 3. roots (HASH_SIZE per stage, nStages+1 stages)
      for root in self.roots:
          values.extend(root[:HASH_SIZE])

      # 4. evals (FIELD_EXTENSION per eval)
      for eval_val in self.evals:
          values.extend(eval_val[:FIELD_EXTENSION])

      # 5-9. Query proofs (const tree, custom commits, stage trees)
      # ... (follow exact C++ proof2pointer() ordering)

      # 10-11. FRI step roots and query proofs
      # ...

      # 12. finalPol (FIELD_EXTENSION per coefficient)
      for coef in self.fri.pol:
          values.extend(coef[:FIELD_EXTENSION])

      # 13. nonce
      values.append(self.nonce)

      return struct.pack(f'<{len(values)}Q', *values)
  ```

- [ ] **Add unit test** for `to_bytes()` output size
  - Verify `len(proof.to_bytes())` matches expected `proof_size * 8`

#### Task #3: Add byte equivalence test

- [ ] **Add `test_proof_bytes_match`** to `test_stark_e2e.py`
  - File: `executable-spec/tests/test_stark_e2e.py`

  ```python
  class TestProofBytesEquivalence:
      """Byte-level proof equivalence - catches any divergence."""

      @pytest.mark.parametrize('air_name', ['simple', 'lookup', 'permutation'])
      def test_proof_bytes_match(self, air_name):
          """Compare raw proof bytes from Python vs C++."""
          config = AIR_CONFIGS[air_name]

          # Load C++ proof bytes
          bin_path = TEST_DATA_DIR / config['test_vector'].replace('.json', '.proof.bin')
          if not bin_path.exists():
              pytest.fail(f"Proof binary not found: {bin_path}")

          with open(bin_path, 'rb') as f:
              expected_bytes = f.read()

          # Generate Python proof
          setup_ctx = load_setup_ctx(air_name)
          vectors = load_test_vectors(air_name)
          params = create_params_from_vectors(setup_ctx.stark_info, vectors)
          transcript = create_transcript_from_state(
              setup_ctx.stark_info,
              vectors['intermediates']['transcript_state_step0'],
              vectors['inputs'].get('global_challenge')
          )

          proof = gen_proof(setup_ctx, params, transcript=transcript,
                           captured_roots=vectors.get('intermediates', {}).get('roots'))

          # Serialize and compare
          actual_bytes = proof.to_bytes(setup_ctx.stark_info)

          if actual_bytes != expected_bytes:
              first_diff = next(
                  (i for i, (a, b) in enumerate(zip(actual_bytes, expected_bytes)) if a != b),
                  min(len(actual_bytes), len(expected_bytes))
              )
              pytest.fail(
                  f"Proof bytes mismatch!\n"
                  f"Expected {len(expected_bytes)} bytes, got {len(actual_bytes)} bytes\n"
                  f"First difference at byte {first_diff} (uint64 index {first_diff // 8})"
              )
  ```

---

## Binary Layout Reference (from C++ `proof2pointer()`)

The proof is serialized as a flat `uint64_t[]` in this exact order:

1. `airgroupValues[i][k]` - FIELD_EXTENSION (3) per entry
2. `airValues[i][k]` - FIELD_EXTENSION (3) per entry
3. `roots[stage][k]` - HASH_SIZE (4) per stage, nStages+1 stages
4. `evals[i][k]` - FIELD_EXTENSION (3) per eval
5. For each query: `constTree.polQueries[i].v[l]` (values)
6. For each query: `constTree.polQueries[i].mp[l][k]` (merkle paths)
7. `constTree.last_levels[k]` (if lastLevelVerification > 0)
8. For each customCommit: query values, merkle paths, last_levels
9. For each stage (cm1..cmQ): query values, merkle paths, last_levels
10. FRI step roots: `fri.treesFRI[step].root[k]`
11. For each FRI step: query values, merkle paths, last_levels
12. `fri.pol[i][k]` - FIELD_EXTENSION (3) per coefficient
13. `nonce` - single uint64

---

## Implementation Workflow

### Required Process
1. **Load Plan**: Read this entire plan file before starting
2. **Execute sequentially**: Task #1 → Task #2 → Task #3
3. **Update checkboxes**: Mark `[x]` when each item is complete

### Progress Tracking
The checkboxes above represent the authoritative status of each task.
