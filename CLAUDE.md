pil2-proofman is a SNARK library used by the zisk zkvm.

## Conventions
Filenames use - (hyphen) for separators, not _ (underscore) whenever possible.

## Tests

### Setup

Before running tests the first time, set up the proving keys:

```bash
./setup.sh              # set up all tests (simple + lookup + permutation)
./setup.sh simple       # set up only simple test
./setup.sh lookup       # set up only lookup test
./setup.sh permutation  # set up only permutation test
```

Requires `pil2-compiler` and `pil2-proofman-js` as sibling directories.

### Python Executable Spec

The Python implementation in `executable-spec/` is a complete STARK prover and verifier that produces byte-identical proofs to the C++ implementation.

**Supported AIRs:**
- **SimpleLeft**: 8 rows, basic constraints (no FRI folding)
- **Lookup2_12**: 4096 rows, complex lookup operations (has FRI folding)
- **Permutation1_6**: 64 rows, permutation constraints (has FRI folding)

**Generate test vectors** (requires setup.sh first):
```bash
./generate-test-vectors.sh              # generate all test vectors
./generate-test-vectors.sh simple       # generate SimpleLeft only
./generate-test-vectors.sh lookup       # generate Lookup2_12 only
./generate-test-vectors.sh permutation  # generate Permutation1_6 only
```

**Run Python tests:**
```bash
cd executable-spec
./run-tests.sh                # all 171 tests
./run-tests.sh e2e            # E2E tests (prover + verifier vs C++)
./run-tests.sh prover         # prover E2E only
./run-tests.sh verifier       # verifier E2E only
./run-tests.sh fri            # FRI protocol tests
./run-tests.sh constraints    # constraint module tests
./run-tests.sh witness        # witness module tests
./run-tests.sh simple         # SimpleLeft AIR tests
./run-tests.sh lookup         # Lookup2_12 AIR tests
./run-tests.sh permutation    # Permutation1_6 AIR tests
./run-tests.sh unit           # unit tests (non-E2E, fast)
./run-tests.sh -k "pattern"   # pytest -k filter
```

**Test suite overview (171 tests):**

| Test File | Description |
|-----------|-------------|
| `test_stark_e2e.py` | Full prover E2E tests with byte-level binary proof comparison against C++ |
| `test_verifier_e2e.py` | Verifier tests against C++ proof fixtures (*.proof.bin) |
| `test_fri.py` | FRI layer tests - folding, commitment, query generation |
| `test_constraint_context.py` | Constraint context ABC and implementations |
| `test_constraint_verifier.py` | Verifier constraint evaluation |
| `test_*_constraints.py` | Per-AIR constraint module tests |
| `test_*_witness.py` | Per-AIR witness module tests |
| `test_stark_info.py` | StarkInfo JSON parsing validation |
| `test_proof.py` | Proof serialization/deserialization |
| `test_ntt.py` | NTT/INTT operations |
| `test_batch_inverse.py` | Montgomery batch inversion |
| `test_expressions_bin.py` | Expression binary parser tests |
| `test_bytecode_equivalence.py` | Bytecode vs hand-written constraint equivalence |

**Test data directory (`executable-spec/tests/test-data/`):**
- `*.json` - JSON test vectors with inputs, intermediates, and expected outputs
- `*.proof.bin` - Binary proofs generated by C++ prover
- `*.proof.py.bin` - Binary proofs generated by Python prover (for debugging)

**Key test classes:**
- `TestStarkE2EComplete` - Full proof generation with binary comparison to C++
- `TestFullBinaryComparison` - Byte-level proof verification
- `TestVerifierE2E` - Verifies C++ proofs pass Python verification

### C++ FRI Pinning Vectors

To regenerate C++ FRI pinning vectors (for `pil2-stark/tests/fri-pinning/fri_pinning_vectors.hpp`):

```bash
./generate-fri-vectors.sh          # regenerate all vectors (default)
./generate-fri-vectors.sh simple   # regenerate SimpleLeft only
./generate-fri-vectors.sh lookup   # regenerate Lookup2_12 only
```

## Code Review Agents

After modifying Python code in `executable-spec/`, run these review agents (via the Task tool) before considering work complete:

- **zksnark-python-style** — after writing/modifying Python in executable-spec/
- **human-simplicity-enforcer** — after writing/refactoring code, check readability
- **protocol-purity-guardian** — after modifying anything in protocol/
- **paranoid-skeptic** — after any significant changes, verify no regressions

## Python Executable Spec Architecture

### Package Structure

```
executable-spec/
├── constraints/         # Per-AIR constraint polynomial modules
│   ├── base.py          # ConstraintModule ABC, ProverConstraintContext
│   ├── bytecode_adapter.py # BytecodeConstraintModule (bytecode fallback)
│   ├── simple_left.py   # SimpleLeft constraint implementation
│   ├── lookup2_12.py    # Lookup2_12 constraint implementation
│   └── permutation1_6.py # Permutation1_6 constraint implementation
│
├── witness/             # Per-AIR witness generation modules
│   ├── base.py          # WitnessModule ABC
│   ├── bytecode_adapter.py # BytecodeWitnessModule (bytecode fallback)
│   ├── simple_left.py   # SimpleLeft witness (im_cluster, gsum)
│   ├── lookup2_12.py    # Lookup2_12 witness
│   └── permutation1_6.py # Permutation1_6 witness
│
├── primitives/          # Low-level cryptographic building blocks
│   ├── field.py         # Goldilocks field FF and cubic extension FF3
│   ├── ntt.py           # Number Theoretic Transform
│   ├── merkle_tree.py   # Merkle tree construction and proofs
│   ├── merkle_prover.py # Merkle tree prover abstraction
│   ├── merkle_verifier.py # Merkle tree verifier abstraction
│   ├── transcript.py    # Fiat-Shamir transcript (Poseidon2)
│   ├── poseidon2-ffi/   # Rust FFI for Poseidon2 hash
│   └── expression_bytecode/ # Recovered bytecode interpreter (isolated)
│       ├── expressions_bin.py    # Binary expression parser
│       ├── expression_evaluator.py # Bytecode evaluation engine
│       └── witness_generation.py  # Hint-driven witness computation
│
├── protocol/            # STARK protocol implementation
│   ├── prover.py        # Main proof generation entry point
│   ├── verifier.py      # Proof verification
│   ├── fri.py           # FRI folding protocol
│   ├── pcs.py           # FRI polynomial commitment scheme
│   ├── stages.py        # Prover stage orchestration
│   ├── fri_polynomial.py # FRI polynomial computation
│   ├── stark_info.py    # StarkInfo JSON parser
│   ├── air_config.py    # AIR configuration and ProverHelpers
│   ├── data.py          # ProverData/VerifierData for constraint modules
│   └── proof.py         # Proof data structures and serialization
│
├── tests/               # Test suite (171 tests)
├── setup.sh             # Environment setup (uv sync + poseidon2-ffi)
└── run-tests.sh         # Test runner with filters
```

### Data Model

**ProverData / VerifierData** (protocol/data.py) provide dict-based storage with named columns, used by constraint and witness modules for readable AIR-specific code. Protocol internals (Merkle trees, NTT, FRI) work directly with numpy arrays.

### Type System

The codebase uses galois library for field arithmetic with semantic type aliases:

```python
# Base types (from galois library)
FF   # Base field GF(p) - Goldilocks prime
FF3  # Cubic extension GF(p^3)

# Type aliases for semantic clarity (in primitives/field.py)
FF3Poly    # Polynomial over extension field (FRI, NTT)
FFPoly     # Polynomial over base field
FF3Column  # Column of values at N evaluation points
FFColumn   # Column of base field values
HashOutput # 4-element Poseidon hash output

# Constants
FIELD_EXTENSION_DEGREE = 3  # Cubic extension degree
```
